what is microservice ?


all logic to one feature work correctly.



challenge : Data management between services

each service gets its own database.
services never will reach to each other dbs.


it is pattern : Database per service

we want run it independetly.





Sync and Async in microsevices :


Sync : services communicate with each other using direct request
       web of dependency



Async : Services communicate with each other with events. event based
        Event bus , each service emit events or receive events from event
        bus.


second way async communicate :
each service , one db.

how catch our need info from other serivces.

simontinously save to db and send event to Event bus. for any body care 
about it.




============================================================



Blog Post application :



============================================================


running service with Docker :


build with docker files and docker ignore files.

each service.


now we want use k8s

service: sth that give us access to running ads or running
container.

kubectl apply -f posts.yaml 

kind pod : it is object wrap up container.
metadata: config ooptions for object we are going to create.
spec : list of config options the pod that we are about to create. 


k get pods



deployment is a k8s object that is intended to manage set of pods.
 it check pods exists.
 use for update.


#      selector        says he k8s look at all pods with created with matchlabels param and watch it

in template labels define label for selector.


// many thing not saved like 70 lines



skaffold , 

==============================================


the big challenge is managing data :




async , 


STUBHUB


===========================================================


k8s cluster = nodes + matster for manage

node = a vm run our containers

pod = almost a running container technically

deployment = monintors set of pods, make sure they are.

service =  provide a easy remmebmer url to access other running container


---

k8s config files :

it say to k8s about objects (deployments , pods , services)

in yaml syntax

it is kind of documentation for cluster
allow others know what are you doing

create pod

create image 
define file
create with kubectl
kubectl apply -f nameoffile


about config :


apiVersion : api of object we want use it must contain set of objects

kind : type of object from api

metadata : config we want to apply to the object,
        options we want apply like name

spec : exact attributes we want our oject have, list of config options  

        containers : we can create many containers in a pod
                we add array of them here


run yaml file with  kubectl 

first build image\
push to hub
write yaml file for pod/deployment and service
use kubectl to build pod/deployment and service

kubectl apply -f posts.yaml
kubectl get pods

docker exec -it ... = k exec -it ...

k logs ... = show log of terminal for microservice


deployment is managar for pods
write yaml file for it.

spec : how deployment must behave

in spec section of deployment
selector says he k8s look at all pods with created with matchlabels param and 
watch it for me

when use deployment if we delete pod or any problem , deployment will 
generate new one

k describe deployment 
k logs [pod name]
check event






for update deployment :
there are ways for this .
1 : update image in hub. update image version in yaml.
    now must inform k8s. k apply -f file.name -> show configured.
    (not good to change that number each time)
2 : use latest tag on image or leave it off. update code . build image .
    push to hub . then use command
    k rollout restart deployment [depl name]






now services :
by services we allow to use our pods (before it is hidden)
service is object. default type is ClusterIp.
4 type ClusterIp (expose pods only in cluster) and 
       loadBalancer(outside w) for daily use
       nodeport (dev outside w) 
       externalName (redirect to c name)





in spec/selector of serivce we put name of pod we want expose to world

port listen on LVM (also allow access out world).
targetPort listen on our piece of app.


nodePort(browser) -> port(NodePort service) -> targetPort(pod)

[minikubei ip]:[nodePort]/${route}





write services in one file
hint : ClusterIp services exists with NodePort or loadBalancer at same.

hint hint : use k explain pods or services so cool




how communicate between serivces???
change name of route in axios or what ever to name of
http://[ClusterIp service name]:[port(other ClusterIp)]/[route you defined]
(this case is when you have not famous message broker)




loadBalancer service :

cra go in pod.
in spa case all req come to pods from browser.
therefore we must only serve static files.

but how cra connect to others

cra --> loadBalancer service ->> it connect to all ClusterIp s

now make sure cra connect to it 
and make yaml for loadBalancer





loadBalancer service : tells k8s to reach out to its provider and provision a 
        loadBalancer . get traffic to single pod
        (do it in front with nginx)
        cluster is in cloud provider we want out world traffic in.
        make config for it . feed to cluster 
        it says to our cluster go and reach out to our cloud provider
        and provision sth called LoadBalancer
        it exists outside cluster in cloud provider - part of google or aws


Ingress or Ingress Controller : a pod with a set of routing rules to distribute traffic
        to other service.
        (do it with ingress-srv)
        it work along side top service and give it rule of routing to choose best
        pod 



outside(react browser)-> loadBalancer(cloud)-> cluster(ingress(rule routes)-> srv.pods)





we use ingress-nginx (check github) 
ingress-nginx = create both loadBalancer  +  Ingress

also there is another kubernetes-ingress

go website -> deployment -> installitaion guide


run mandatory command (give u yaml)
for this add  ingress from his website or addons enable minikube

provider specific command (give u yaml)
for this define yaml
{
        kind: Ingress
}

annotations : help ingress Controller understand we try to feed him some rules 
so ingress continusly scan objects and try to find someone who has below annotaions
kubernetes.io/ingress.class: nginx

nginx have some rule for me
allow us use regex

spec:
        rules : teach ingress here
        define host : [posts.com]
               http
                 paths
                   path
                   backend
                     serviceName
                     serivcePort




with k8s and his cluster we can host many sites 
we trick our machine to conect local host go to posts.com
edit -> /etc/hosts add [minikube ip] [name of host you want]



Now CRA :
change rotue to posts.com
make yaml file for react

last step :
add rules to ingress service
ingress can not do routing base on Method of request










To update and change env in dev env we use automate tool
https://stackshare.io/skaffold/alternatives
can use helm or other in prod




skaffold :
automate task in k8s
you can not use in prod

can change set of objects quickly.


create yaml file for it in root of all proj

when stop it delete all objects.
local/push : false prevent it to push and build image to docker hub
on each save

artifacts:  array of each image with their config
        if change is not in manual path , skaffold rebuild image
        like changes in package.json



to start
skaffold dev 


must always use to nodemon to make changes.

sometimes detecting not change we fix it in future.


----------------------------

NExt Project :

big challenge is data ,
we use async communication (with message brokers) with events
with async every service is self sufficient 100%
we use k8s for scale and deploy

we build npm to share code - central lib for share services
must define all our events in our library to know what happen
we also handle concurrency


overview of app :

STUBHUB

user collection , tickets collection ,  order collection , charge


we have 5 services

auth, tickets , orders , expiration , payments


events and architecture :
userCreated, userUpdated ... OrderCancelled , OrederCreated , ...
ticketCreated , chargeCreated ...


client(nextjs)-->
common (shared lib) -->
microservices with mongo , redis -> 
nats streaming server

----

auth service start 

install dependencies

tsc --init 

create src

index.ts

simple server 

now start k8s infrastructure from start

make docker file
make docker ignore file

build image
docker build -t penkong/stubhub-auth .

make infra/k8s folder 

wrtie auth-deployment with ClusterIp service

make skaffold - it read from local
(deploy section load all yaml file we want
in sync manual dest: . means where to sync file to inside running container
get file from src and through it container
)

start minikube

skaffold dev (if not reload use this in package ts-node-dev --poll src/index.ts)


now we want access our service
now set up ingress-nginx (loadBalancer --> ingress Controller)


make it available in minikube or server


write yaml for nginx - define domain
browsers does not trust ssl from server 
type anywhere in tab thisisunsafe






































